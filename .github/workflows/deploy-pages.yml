name: Deploy MkDocs to GitHub Pages

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Needed to diff against previous commit on push
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # Notify internal API when new markdown docs are added to main.
      # Required GitHub Secrets:
      # - DOCS_NOTIFY_URL
      # Optional:
      # - DOCS_NOTIFY_TOKEN (e.g. Bearer token)
      - name: Notify (new docs added)
        if: ${{ github.event_name == 'push' }}
        continue-on-error: true
        env:
          DOCS_NOTIFY_URL: ${{ secrets.DOCS_NOTIFY_URL }}
          DOCS_NOTIFY_TOKEN: ${{ secrets.DOCS_NOTIFY_TOKEN }}
          BEFORE_SHA: ${{ github.event.before }}
          AFTER_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail

          if [ -z "${DOCS_NOTIFY_URL:-}" ]; then
            echo "DOCS_NOTIFY_URL not set; skipping notify."
            exit 0
          fi

          # Collect added markdown files under docs/
          # NOTE: github.event.before can be all-zero on first push / force-push.
          EMPTY_TREE="4b825dc642cb6eb9a060e54bf8d69288fbee4904"
          BASE_SHA="${BEFORE_SHA}"
          if [ -z "${BASE_SHA}" ] || [ "${BASE_SHA}" = "0000000000000000000000000000000000000000" ]; then
            BASE_SHA="${EMPTY_TREE}"
          fi
          if ! git cat-file -e "${BASE_SHA}^{commit}" 2>/dev/null && [ "${BASE_SHA}" != "${EMPTY_TREE}" ]; then
            # Fall back to empty tree if base commit isn't available.
            BASE_SHA="${EMPTY_TREE}"
          fi
          # Try to detect adds/renames/copies robustly.
          git diff --name-status -M -C "$BASE_SHA" "$AFTER_SHA" > /tmp/changed.txt || true
          echo "=== docs notify diff (name-status) ==="
          sed -n '1,200p' /tmp/changed.txt || true

          python - <<'PY'
          import json, os, re, subprocess, sys

          before = os.environ.get("BEFORE_SHA", "")
          after = os.environ.get("AFTER_SHA", "")

          def run(cmd):
            return subprocess.check_output(cmd, text=True).strip()

          def read_file_at(ref, path):
            try:
              return subprocess.check_output(["git", "show", f"{ref}:{path}"], text=True, stderr=subprocess.DEVNULL)
            except subprocess.CalledProcessError:
              return ""

          changed = open("/tmp/changed.txt", "r", encoding="utf-8").read().splitlines()
          added_paths = []
          for line in changed:
            # Formats:
            # - A\tpath
            # - R100\told\tnew
            # - C100\told\tnew
            parts = line.split("\t")
            if len(parts) < 2:
              continue
            status = parts[0].strip()
            status_letter = status[:1]

            path = None
            if status_letter == "A" and len(parts) >= 2:
              path = parts[1].strip()
            elif status_letter in ("R", "C") and len(parts) >= 3:
              # Treat rename/copy destination as "new"
              path = parts[2].strip()

            if not path:
              continue
            if not path.startswith("docs/"):
              continue
            if not path.lower().endswith(".md"):
              continue
            added_paths.append(path)

          def parse_title(md_text: str) -> str:
            # Try YAML frontmatter "title:" first
            m = re.match(r"(?s)^---\n(.*?)\n---\n", md_text)
            if m:
              fm = m.group(1)
              for line in fm.splitlines():
                if line.strip().lower().startswith("title:"):
                  return line.split(":", 1)[1].strip().strip('"').strip("'")
            # Fallback to first markdown H1 heading
            for line in md_text.splitlines():
              s = line.strip()
              if s.startswith("# "):
                return s[2:].strip()
            return ""

          items = []
          for path in added_paths:
            md = read_file_at(after, path)
            folder = "/".join(path.split("/")[:-1]).replace("docs/", "", 1)  # e.g. "zh/EnRouter/IR302"
            doc = os.path.splitext(os.path.basename(path))[0]               # e.g. "quickstart"
            title = parse_title(md)
            items.append({"path": path, "folder": folder, "doc": doc, "title": title})

          payload = {
            "repo": os.environ.get("GITHUB_REPOSITORY", ""),
            "ref": os.environ.get("GITHUB_REF_NAME", ""),
            "before": before,
            "after": after,
            "added": items,
          }

          out = "/tmp/docs-added.json"
          with open(out, "w", encoding="utf-8") as f:
            json.dump(payload, f, ensure_ascii=False)

          print(f"Added docs detected: {len(items)}")
          for it in items[:20]:
            print(" -", it.get("path"))
          PY

          # Skip if no docs added
          if python -c "import json; import sys; d=json.load(open('/tmp/docs-added.json','r',encoding='utf-8')); sys.exit(0 if d.get('added') else 1)"; then
            :
          else
            echo "No new docs added; skipping notify."
            exit 0
          fi

          AUTH_HEADER=()
          if [ -n "${DOCS_NOTIFY_TOKEN:-}" ]; then
            AUTH_HEADER=(-H "Authorization: Bearer ${DOCS_NOTIFY_TOKEN}")
          fi

          # Never fail the pipeline due to notify issues.
          set +e
          RESP="$(curl -sS -w $'\n%{http_code}' -X POST "${DOCS_NOTIFY_URL}" \
            -H "Content-Type: application/json" \
            "${AUTH_HEADER[@]}" \
            --data-binary "@/tmp/docs-added.json")"
          CURL_EC=$?
          set -e
          if [ "$CURL_EC" -ne 0 ]; then
            echo "Notify request failed (curl exit $CURL_EC); continuing."
            exit 0
          fi
          CODE="$(printf '%s' "$RESP" | tail -n 1)"
          BODY="$(printf '%s' "$RESP" | sed '$d')"
          echo "Notify HTTP status: $CODE"
          printf '%s' "$BODY" | head -c 800 || true

      # Build Chinese site to /
      - name: Build (zh)
        run: |
          python -m mkdocs build -f mkdocs.yml -d site --clean

      # Build English site to /en/
      - name: Build (en)
        run: |
          python -m mkdocs build -f mkdocs.en.yml -d site/en

      # Prepare Chinese-only artifact for deployments (exclude /en)
      - name: Prepare artifact (zh only)
        run: |
          rm -rf site-zh
          mkdir -p site-zh
          rsync -a --delete --exclude 'en/' site/ site-zh/

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: site

      - name: Upload artifact (zh only)
        uses: actions/upload-artifact@v4
        with:
          name: site-zh
          path: site-zh

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

  deploy_ecs_zh:
    name: Deploy zh docs to ECS (SSH)
    needs: build
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - name: Download artifact (zh only)
        uses: actions/download-artifact@v4
        with:
          name: site-zh
          path: site-zh

      # Using password auth (less secure than SSH keys).
      # Required GitHub Secrets:
      # - ECS_HOST, ECS_USER, ECS_PASSWORD
      # Optional:
      # - ECS_SSH_PORT (default 22)
      - name: Install sshpass (for password SSH)
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass

      # Host key scan can fail due to networking / firewall.
      # We disable strict host key checking for this deploy job instead.
      - name: Add ECS host key (best effort)
        env:
          ECS_HOST: ${{ secrets.ECS_HOST }}
          ECS_SSH_PORT: ${{ secrets.ECS_SSH_PORT }}
        run: |
          mkdir -p ~/.ssh
          PORT_RAW="${ECS_SSH_PORT:-22}"
          PORT="$(printf '%s' "$PORT_RAW" | tr -d '"'\'' ' )"
          if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
            echo "Invalid ECS_SSH_PORT='$PORT_RAW' -> using 22"
            PORT="22"
          fi
          ssh-keyscan -p "$PORT" "${ECS_HOST}" >> ~/.ssh/known_hosts || true

      - name: Sync to ECS (atomic directory swap)
        env:
          ECS_HOST: ${{ secrets.ECS_HOST }}
          ECS_USER: ${{ secrets.ECS_USER }}
          ECS_PASSWORD: ${{ secrets.ECS_PASSWORD }}
          ECS_SSH_PORT: ${{ secrets.ECS_SSH_PORT }}
        run: |
          set -euo pipefail
          PORT_RAW="${ECS_SSH_PORT:-22}"
          PORT="$(printf '%s' "$PORT_RAW" | tr -d '"'\'' ' )"
          if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
            echo "Invalid ECS_SSH_PORT='$PORT_RAW' -> using 22"
            PORT="22"
          fi
          DOCS_DIR="/var/www/html/static/resources-center-docs"
          NEW_DIR="${DOCS_DIR}.__new__"
          OLD_DIR="${DOCS_DIR}.__old__"

          SSH="sshpass -p \"$ECS_PASSWORD\" ssh -p $PORT -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o PreferredAuthentications=password -o PubkeyAuthentication=no -o NumberOfPasswordPrompts=1"
          RSYNC_SSH="sshpass -p \"$ECS_PASSWORD\" ssh -p $PORT -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o PreferredAuthentications=password -o PubkeyAuthentication=no -o NumberOfPasswordPrompts=1"

          $SSH "${ECS_USER}@${ECS_HOST}" "rm -rf \"$NEW_DIR\" && mkdir -p \"$NEW_DIR\""

          rsync -az --delete -e "$RSYNC_SSH" "site-zh/" "${ECS_USER}@${ECS_HOST}:$NEW_DIR/"

          $SSH "${ECS_USER}@${ECS_HOST}" "test -f \"$NEW_DIR/index.html\""
          $SSH "${ECS_USER}@${ECS_HOST}" "rm -rf \"$OLD_DIR\"; if [ -d \"$DOCS_DIR\" ]; then mv \"$DOCS_DIR\" \"$OLD_DIR\"; fi; mv \"$NEW_DIR\" \"$DOCS_DIR\""

  deploy_s3_zh:
    name: Deploy zh docs to AWS S3
    needs: deploy_ecs_zh
    if: ${{ always() }}
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - name: Download artifact (zh only)
        uses: actions/download-artifact@v4
        with:
          name: site-zh
          path: site-zh

      # Required GitHub Secrets:
      # - AWS_ACCESS_KEY_ID
      # - AWS_SECRET_ACCESS_KEY
      # - AWS_REGION
      # - AWS_S3_BUCKET
      # - CLOUDFRONT_DISTRIBUTION_ID
      # Optional:
      # - AWS_S3_PREFIX (default: resources-center/docs/)
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Sync to S3 (mirror)
        env:
          AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          AWS_S3_PREFIX: ${{ secrets.AWS_S3_PREFIX }}
        run: |
          set -euo pipefail
          DEST_PREFIX="${AWS_S3_PREFIX:-resources-center/docs/}"
          aws s3 sync "site-zh/" "s3://${AWS_S3_BUCKET}/${DEST_PREFIX}" --delete

      - name: Invalidate CloudFront cache
        env:
          CLOUDFRONT_DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
          AWS_S3_PREFIX: ${{ secrets.AWS_S3_PREFIX }}
        run: |
          set -euo pipefail
          DEST_PREFIX="${AWS_S3_PREFIX:-resources-center/docs/}"
          # Ensure prefix ends with a single slash for CloudFront paths.
          DEST_PREFIX="${DEST_PREFIX%/}/"
          aws cloudfront create-invalidation \
            --distribution-id "$CLOUDFRONT_DISTRIBUTION_ID" \
            --paths "/${DEST_PREFIX}*"
